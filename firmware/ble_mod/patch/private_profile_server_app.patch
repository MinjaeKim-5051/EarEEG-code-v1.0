--- /c/Users/minjaeKim/Desktop/ori/private_profile_server.c	2026-01-30 02:27:12.000000000 +0900
+++ /c/Users/minjaeKim/Desktop/new/private_profile_server.c	2024-09-11 14:41:56.000000000 +0900
@@ -57,2 +57,103 @@
 
+#include "fsl_debug_console.h"
+#include "fsl_i2c.h"
+#include "fsl_i2c_dma.h"
+#include "fsl_ctimer.h"
+
+#include "clock_config.h"
+#include "pin_mux.h"
+#include "stdio.h"
+#include "string.h"
+#include "stdbool.h"
+#include "stdlib.h"
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+#define EXAMPLE_I2C_MASTER_BASE (I2C1_BASE)
+#define EXAMPLE_I2C_SLAVE_BASE (I2C0_BASE)
+#define I2C_MASTER_CLOCK_FREQUENCY (8000000)
+#define I2C_SLAVE_CLOCK_FREQUENCY (8000000)
+
+#define EXAMPLE_DMA DMA0
+#define EXAMPLE_I2C_MASTER_CHANNEL 5
+
+#define EXAMPLE_I2C_MASTER ((I2C_Type *)EXAMPLE_I2C_MASTER_BASE)
+#define EXAMPLE_I2C_SLAVE ((I2C_Type *)EXAMPLE_I2C_SLAVE_BASE)
+
+#define I2C_MASTER_SLAVE_ADDR_7BIT (0x58U)
+#define I2C_BAUDRATE (100000) /* 100K */
+#define I2C_DATA_LENGTH (6)  /* MAX is 256 */
+
+#define CTIMER CTIMER1                 /* Timer 3 */
+#define CTIMER_MAT_OUT kCTIMER_Match_0 /* Match output 2 */
+#define BUS_CLK_FREQ CLOCK_GetFreq(kCLOCK_ApbClk)
+
+#define run_I2C_length	2000 // 72 // 36 // 2000
+#define tx_length		216
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+/*******************************************************************************
+ * Variables
+ ******************************************************************************/
+
+uint8_t g_slave_buff[I2C_DATA_LENGTH];
+uint8_t g_master_buff[I2C_DATA_LENGTH];
+uint8_t g_check_buff[I2C_DATA_LENGTH];
+
+// uint8_t g_master_excel[run_I2C_length][I2C_DATA_LENGTH];
+uint8_t g_master_excel_1[run_I2C_length][I2C_DATA_LENGTH/2];
+uint8_t g_master_excel_2[run_I2C_length][I2C_DATA_LENGTH/2];
+
+// unsigned long g_master_merge[run_I2C_length];
+unsigned long g_master_merge_1[run_I2C_length];
+unsigned long g_master_merge_2[run_I2C_length];
+unsigned long g_master_merge[run_I2C_length*2];
+
+// unsigned long send_data[run_I2C_length];
+unsigned long send_data[run_I2C_length*2];
+uint8_t gAppSerMgrIf;
+
+i2c_master_dma_handle_t g_m_dma_handle;
+i2c_slave_handle_t g_s_handle;
+dma_handle_t dmaHandle;
+volatile bool g_slaveCompleted = false;
+volatile bool g_masterCompleted = false;
+
+/*******************************************************************************
+ * Code
+ ******************************************************************************/
+
+static void i2c_slave_callback(I2C_Type *base, volatile i2c_slave_transfer_t *xfer, void *param)
+{
+    switch (xfer->event)
+    {
+        /* Setup the slave receive buffer */
+        case kI2C_SlaveReceiveEvent:
+            xfer->rxData = g_slave_buff;
+            xfer->rxSize = I2C_DATA_LENGTH;
+            break;
+
+        /* The master has sent a stop transition on the bus */
+        case kI2C_SlaveCompletionEvent:
+            g_slaveCompleted = true;
+            break;
+
+        /* Transmit event not handled in this demo */
+        case kI2C_SlaveTransmitEvent:
+            xfer->txData = g_slave_buff;
+            xfer->txSize = I2C_DATA_LENGTH;
+            break;
+
+        default:
+            break;
+    }
+}
+
+static void i2c_master_dma_callback(I2C_Type *base, i2c_master_dma_handle_t *handle, status_t status, void *userData)
+{
+    g_masterCompleted = true;
+}
 /************************************************************************************
@@ -174,2 +275,149 @@
 
+static void FPGA_ctimer(void)
+{
+	ctimer_config_t config;
+	ctimer_match_config_t matchConfig;
+
+	CTIMER_GetDefaultConfig(&config);
+	CTIMER_Init(CTIMER, &config);
+
+	BOARD_InitPins();
+	BOARD_BootClockRUN();
+	BOARD_InitDebugConsole();
+
+	matchConfig.enableCounterReset = true;
+	matchConfig.enableCounterStop = false;
+	matchConfig.matchValue = CLOCK_GetFreq(kCLOCK_ApbClk) / (8388608/2);
+	matchConfig.outControl = kCTIMER_Output_Toggle;
+	matchConfig.outPinInitState = true;
+	matchConfig.enableInterrupt = false;
+	CTIMER_SetupMatch(CTIMER, CTIMER_MAT_OUT, &matchConfig);
+	CTIMER_StartTimer(CTIMER);
+
+}
+
+
+
+static void Ble_I2C(void)
+{
+	i2c_slave_config_t slaveConfig;
+
+	i2c_master_config_t masterConfig;
+	i2c_master_transfer_t masterXfer;
+
+	DMA_Init(EXAMPLE_DMA);
+
+	I2C_SlaveGetDefaultConfig(&slaveConfig);
+
+	/* Change the slave address */
+	slaveConfig.address0.address = I2C_MASTER_SLAVE_ADDR_7BIT;
+
+	/* Initialize the I2C slave peripheral */
+	I2C_SlaveInit(EXAMPLE_I2C_SLAVE, &slaveConfig, I2C_SLAVE_CLOCK_FREQUENCY);
+
+	memset(g_slave_buff, 0, sizeof(g_slave_buff));
+
+	I2C_SlaveTransferCreateHandle(EXAMPLE_I2C_SLAVE, &g_s_handle, i2c_slave_callback, NULL);
+	I2C_SlaveTransferNonBlocking(EXAMPLE_I2C_SLAVE, &g_s_handle, kI2C_SlaveCompletionEvent);
+
+
+	I2C_MasterGetDefaultConfig(&masterConfig);
+
+	/* Change the default baudrate configuration */
+	masterConfig.baudRate_Bps = I2C_BAUDRATE;
+
+	/* Initialize the I2C master peripheral */
+	I2C_MasterInit(EXAMPLE_I2C_MASTER, &masterConfig, I2C_MASTER_CLOCK_FREQUENCY);
+
+	memset(&g_m_dma_handle, 0, sizeof(g_m_dma_handle));
+	memset(&masterXfer, 0, sizeof(masterXfer));
+
+
+	DMA_EnableChannel(EXAMPLE_DMA, EXAMPLE_I2C_MASTER_CHANNEL);
+	DMA_CreateHandle(&dmaHandle, EXAMPLE_DMA, EXAMPLE_I2C_MASTER_CHANNEL);
+
+
+	for (uint32_t j = 0U; j < I2C_DATA_LENGTH; j++)
+	{
+		g_master_buff[j] = 0;
+	}
+
+	masterXfer.slaveAddress = I2C_MASTER_SLAVE_ADDR_7BIT;
+	masterXfer.direction = kI2C_Read;
+	masterXfer.subaddress = 0;
+	masterXfer.subaddressSize = 0;
+	masterXfer.data = g_master_buff;
+	masterXfer.dataSize = I2C_DATA_LENGTH;
+	masterXfer.flags = kI2C_TransferDefaultFlag;
+
+	g_masterCompleted = false;
+
+	int one_cycle = 0;
+
+	for (uint32_t j = 0U; j < run_I2C_length; j++)
+	{
+		if (one_cycle < 36)
+		{
+			I2C_MasterTransferCreateHandleDMA(EXAMPLE_I2C_MASTER, &g_m_dma_handle, i2c_master_dma_callback, NULL, &dmaHandle);
+			I2C_MasterTransferDMA(EXAMPLE_I2C_MASTER, &g_m_dma_handle, &masterXfer);
+			while (!g_masterCompleted)
+			{
+			}
+
+			if ((g_check_buff[0] != g_master_buff[0]) || (g_check_buff[1] != g_master_buff[1]) || (g_check_buff[2] != g_master_buff[2]) || (g_check_buff[3] != g_master_buff[3]) || (g_check_buff[4] != g_master_buff[4]) || (g_check_buff[5] != g_master_buff[5]))
+			{
+				for (uint32_t k = 0U; k < (I2C_DATA_LENGTH/2); k++)
+				{
+					// g_master_excel[j][I2C_DATA_LENGTH-k-1] = g_master_buff[k];
+					g_master_excel_1[one_cycle][(I2C_DATA_LENGTH/2)-k-1] = g_master_buff[k];
+					g_master_excel_2[one_cycle][(I2C_DATA_LENGTH/2)-k-1] = g_master_buff[k+(I2C_DATA_LENGTH/2)];
+					g_check_buff[k] = g_master_buff[k];
+					g_check_buff[k+3] = g_master_buff[k+3];
+				}
+				one_cycle++;
+			}
+			g_masterCompleted = false;
+		}
+
+		else if (one_cycle == 36)
+		{
+			break;
+		}
+	}
+
+
+	for (uint32_t p = 0U; p < run_I2C_length/2; p++)
+	{
+		long x5 = (long) g_master_excel_1[p][0]<<16;
+		long x4 = (long) g_master_excel_1[p][1]<<8;
+		long x3 = (long) g_master_excel_1[p][2]; // I2C_DATA_LENGTH
+
+		long x2 = (long) g_master_excel_2[p][0]<<16;
+		long x1 = (long) g_master_excel_2[p][1]<<8;
+		long x0 = (long) g_master_excel_2[p][2]; // I2C_DATA_LENGTH
+
+		g_master_merge_1[p] = x5 | x4 | x3;
+		g_master_merge_2[p] = x2 | x1 | x0;
+
+		g_master_merge[p*2] = g_master_merge_1[p];
+		g_master_merge[p*2+1] = g_master_merge_2[p];
+	}
+
+	/*
+	send_data[0] = g_master_merge[0];
+	send_data[1] = g_master_merge[1];
+	int send_data_pos = 2;
+	for (int w = 2; w < run_I2C_length*2; w+=2)
+	{
+		// if ((g_master_merge[w - 2] != g_master_merge[w]) && (g_master_merge[w - 1] != g_master_merge[w + 1]))
+		// {
+		send_data[send_data_pos] = g_master_merge[w];
+		send_data[send_data_pos+1] = g_master_merge[w+1];
+		send_data_pos+=2;
+		// }
+	}
+	*/
+
+}
+
 /*! *********************************************************************************
@@ -180,3 +428,7 @@
 {
-    /* Initialize application support for drivers */
+	FPGA_ctimer();
+
+	// Ble_I2C();
+
+	/* Initialize application support for drivers */
     BOARD_InitAdc();
@@ -233,13 +485,16 @@
         {
-            for (i = 0; i < gAppMaxConnections_c; i++)
-            {
-              if (mPeerInformation[i].deviceId == gInvalidDeviceId_c)
-                break;
-            }
-            if(i < gAppMaxConnections_c)
-              BleApp_Start();
-            break;
+			for (i = 0; i < gAppMaxConnections_c; i++)
+			{
+			  if (mPeerInformation[i].deviceId == gInvalidDeviceId_c)
+				break;
+			}
+			if(i < gAppMaxConnections_c)
+			  BleApp_Start();
+			break;
+
         }
+
         case gKBD_EventLongPB1_c:
         {
+
             for (i = 0; i < gAppMaxConnections_c; i++)
@@ -662,19 +917,84 @@
 {
-      static uint8_t tx_data[mQppsMaxTestDataLength_c];
-      static uint8_t index = 0;
-      uint8_t i;
-      bleResult_t result;
-      uint8_t txCnt = 0;
 
-      for(i = 1; i<mQppsTestDataLength; i++)
-      {
-          tx_data[i] = i;
-      }
-      tx_data[0] = index;
+	  uint8_t tx_data[tx_length];
+	  static uint16_t index = 0;
+	  bleResult_t result;
+	  uint16_t txCnt = 0;
+	  // int arraylen = run_I2C_length*2;
+	  // unsigned long send_ble[arraylen];
+
+
+	  /*for (int q=0; q<run_I2C_length*2; q++)
+	  {
+		  if (send_data[q] == 0)
+		  {
+			  arraylen = arraylen - 1;
+		  }
+	  }
+
+
+	  for (int w=0; w<arraylen; w++)
+	  {
+		  send_ble[w] = send_data[w];
+	  }
+
+
+	  for (int z=0; z<72; z++)
+	  {
+		  for (int n=0; n<3; n++)
+		  {
+			  tx_data[(3*z)+2-n] = send_ble[index+z];
+			  send_ble[index+z] = send_ble[index+z] >> 8;
+		  }
+	  }*/
+
 
-      for (i = 0; i < gAppMaxConnections_c; i++)
+	  /*for (int i=0; i<3; i++)
+	  {
+		  tx_data[11-i] = send_ble[index+3];
+		  send_ble[index+3] = send_ble[index+3] >> 8;
+
+		  tx_data[8-i] = send_ble[index+2];
+		  send_ble[index+2] = send_ble[index+2] >> 8;
+
+		  tx_data[5-i] = send_ble[index+1];
+		  send_ble[index+1] = send_ble[index+1] >> 8;
+
+		  tx_data[2-i] = send_ble[index];
+		  send_ble[index] = send_ble[index] >> 8;
+	  }*/
+
+
+      for (uint8_t i = 0; i < gAppMaxConnections_c; i++)
       {
-          if ((mPeerInformation[i].deviceId != gInvalidDeviceId_c) && (mPeerInformation[i].ntf_cfg == QPPS_VALUE_NTF_ON))
+          if ((mPeerInformation[i].deviceId != gInvalidDeviceId_c) && (mPeerInformation[i].ntf_cfg == QPPS_VALUE_NTF_ON))// && (index<arraylen))
           {
-              result = Qpp_SendData(mPeerInformation[i].deviceId, service_qpps, mQppsTestDataLength, tx_data);
+
+        	  // arraylen = run_I2C_length*2;
+
+        	  Ble_I2C();
+
+              /*for (int q=0; q<run_I2C_length*2; q++)
+        	  {
+            	  if (g_master_merge[q] == 0)
+        		  {
+        			  arraylen = arraylen - 1;
+        		  }
+        	  }
+
+        	  for (int w=0; w<arraylen; w++)
+        	  {
+        		  send_ble[w] = g_master_merge[w];
+        	  }*/
+
+			  for (int z=0; z<72; z++)
+			  {
+				  for (int n=0; n<3; n++)
+				  {
+					  tx_data[(3*z)+2-n] = g_master_merge[index+z];
+					  g_master_merge[index+z] = g_master_merge[index+z] >> 8;
+				  }
+			  }
+
+			  result = Qpp_SendData(mPeerInformation[i].deviceId, service_qpps, tx_length, tx_data);
 
@@ -682,3 +1002,3 @@
               {
-                  mPeerInformation[i].bytsSentPerInterval += mQppsTestDataLength;
+                  mPeerInformation[i].bytsSentPerInterval += tx_length; //mQppsTestDataLength;
                   txCnt++;
@@ -697,3 +1017,5 @@
       {
-          index++;
+    	  // index = index+72;
+    	  index = index;
+
 #if (mQppsTxInterval_c == 0)
@@ -704,3 +1026,4 @@
 
-/*! *********************************************************************************
+/*! 
+*********************************************************************************
 * \brief        Handles QPPS Thoughput timer callback.
